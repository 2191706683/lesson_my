<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 递归相应的处理方案
        // 程序技术方案 函数 直接或间接的调用自己
        /* 
            函数 执行 ？ 细节
            1. js  使用了 stack 数据结构来维护 程序运行
            2. 函数名 函数体
            函数名(), -> 入栈
            函数反复入栈
        */
        // 栈内存 简单数据类型 存的是值 | 函数运行 "执行"栈 函数入栈的方式 代码的执行顺序
        // 堆内存 复杂数据类型 存的是函数的代码
        const obj = {} // 复用一下
        // 终点
        // 一类相同或相似问题的由大到小的划分， 执行栈的处理方式是一样的
        // 缺点是 内存空间消耗大 好多函数入栈
        const climbStairs = function (n) {
            // 递归深度  自顶向下
            // 函数入栈， 递归优化？   自底向上，  dp
            // 缓存计算结果 用空间换时间
            // Map
            if (obj[n]) {
                return obj[n]
            }
            if (n == 1 || n == 2) {
                return n
            }

            obj[n] = climbStairs(n - 1) + climbStairs(n - 2);
            return obj[n];
            /* if (n == 1 || n == 2) { // 退出条件
                return n
            } else {
                // 99  98楼 +1 97 + 2 爬上来  题意  倒推法，自上而下，终局思维
                // 递归特别适合
                return climbStairs(n - 1) + climbStairs(n - 2)
            } */
        }
        // 
        console.log(climbStairs(99))
    </script>
</body>

</html>